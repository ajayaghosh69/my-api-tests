{
  "info": {
    "_postman_id": "d74bf63a-6955-4c77-a419-999625ad49a8",
    "name": "Demo_User",
    "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
    "_exporter_id": "39356921",
    "_collection_link": "https://go.postman.co/collection/39356921-d74bf63a-6955-4c77-a419-999625ad49a8?source=collection_link"
  },
  "item": [
    {
      "name": "New Request",
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "pm.test(\"First user's email is 'Sincere@april.biz'\", function () {",
              "    const jsonData = pm.response.json();",
              "    pm.expect(jsonData[0].email).to.eql('Sincere@april.biz');",
              "});",
              "",
              "pm.test(\"Every user has a non-null 'company' object\", function () {",
              "    const jsonData = pm.response.json();",
              "    jsonData.forEach((user, index) => {",
              "        pm.expect(user.company, `User at index ${index} should have a company object`).to.not.be.null;",
              "        pm.expect(user.company, `User at index ${index} company should be an object`).to.be.an('object');",
              "    });",
              "});"
            ],
            "type": "text/javascript",
            "packages": {},
            "requests": {}
          }
        },
        {
          "listen": "prerequest",
          "script": {
            "exec": [],
            "type": "text/javascript"
          }
        }
      ],
      "request": {
        "method": "GET",
        "header": [],
        "url": {
          "raw": "https://jsonplaceholder.typicode.com/users",
          "protocol": "https",
          "host": [
            "jsonplaceholder",
            "typicode",
            "com"
          ],
          "path": [
            "users"
          ]
        }
      },
      "response": []
    },
    {
      "name": "New Request",
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// Visualization: Table of Name, Email, Company Name\r",
              "var template = `\r",
              "<table border=\"1\" cellspacing=\"0\" cellpadding=\"6\" style=\"border-collapse: collapse; width: 100%; font-family: Arial, sans-serif; font-size: 13px;\">\r",
              "    <thead style=\"background-color: #f2f2f2;\">\r",
              "        <tr>\r",
              "            <th style=\"text-align: left;\">Name</th>\r",
              "            <th style=\"text-align: left;\">Email</th>\r",
              "            <th style=\"text-align: left;\">Company Name</th>\r",
              "        </tr>\r",
              "    </thead>\r",
              "    <tbody>\r",
              "        {{#each users}}\r",
              "        <tr>\r",
              "            <td>{{this.name}}</td>\r",
              "            <td>{{this.email}}</td>\r",
              "            <td>{{this.company.name}}</td>\r",
              "        </tr>\r",
              "        {{/each}}\r",
              "    </tbody>\r",
              "</table>\r",
              "`;\r",
              "\r",
              "function constructVisualizerPayload() {\r",
              "    return {\r",
              "        users: pm.response.json()\r",
              "    };\r",
              "}\r",
              "\r",
              "pm.visualizer.set(template, constructVisualizerPayload());"
            ],
            "type": "text/javascript",
            "packages": {},
            "requests": {}
          }
        },
        {
          "listen": "prerequest",
          "script": {
            "exec": [],
            "type": "text/javascript"
          }
        }
      ],
      "request": {
        "method": "GET",
        "header": [],
        "url": {
          "raw": "https://jsonplaceholder.typicode.com/users",
          "protocol": "https",
          "host": [
            "jsonplaceholder",
            "typicode",
            "com"
          ],
          "path": [
            "users"
          ]
        }
      },
      "response": []
    },
    {
      "name": "New Request",
      "event": [
        {
          "listen": "test",
          "script": {
            "type": "text/javascript",
            "exec": [
              "// Parse response JSON",
              "const responseJson = pm.response.json();",
              "",
              "// Import Ajv (already available in Postman)",
              "const Ajv = require('ajv');",
              "const ajv = new Ajv({ allErrors: true });",
              "",
              "// JSON Schema",
              "const schema = {",
              "    type: \"array\",",
              "    minItems: 1,",
              "    items: {",
              "        type: \"object\",",
              "        required: [\"id\", \"email\"],",
              "        properties: {",
              "            id: {",
              "                type: \"integer\"",
              "            },",
              "            name: {",
              "                type: \"string\"",
              "            },",
              "            username: {",
              "                type: \"string\"",
              "            },",
              "            email: {",
              "                type: \"string\",",
              "                format: \"email\"",
              "            },",
              "            address: {",
              "                type: \"object\",",
              "                properties: {",
              "                    street: { type: \"string\" },",
              "                    suite: { type: \"string\" },",
              "                    city: { type: \"string\" },",
              "                    zipcode: { type: \"string\" },",
              "                    geo: {",
              "                        type: \"object\",",
              "                        properties: {",
              "                            lat: { type: \"string\" },",
              "                            lng: { type: \"string\" }",
              "                        }",
              "                    }",
              "                }",
              "            },",
              "            phone: {",
              "                type: \"string\"",
              "            },",
              "            website: {",
              "                type: \"string\"",
              "            },",
              "            company: {",
              "                type: \"object\",",
              "                properties: {",
              "                    name: { type: \"string\" },",
              "                    catchPhrase: { type: \"string\" },",
              "                    bs: { type: \"string\" }",
              "                }",
              "            }",
              "        }",
              "    }",
              "};",
              "",
              "// Compile and validate",
              "const validate = ajv.compile(schema);",
              "const isValid = validate(responseJson);",
              "",
              "// Postman assertion",
              "pm.test(\"Response schema validation (id integer & email required)\", function () {",
              "    if (!isValid) {",
              "        console.log(\"Schema validation errors:\", validate.errors);",
              "    }",
              "    pm.expect(isValid).to.be.true;",
              "});",
              "",
              "// ============================================",
              "// ADDITIONAL TESTS - Email Validation",
              "// ============================================",
              "pm.test(\"Email field validation for all users\", function () {",
              "    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;",
              "    let failures = [];",
              "    ",
              "    responseJson.forEach((user, index) => {",
              "        let userFailures = [];",
              "        ",
              "        // Check email exists",
              "        if (!user.hasOwnProperty('email')) {",
              "            userFailures.push(\"email field missing\");",
              "        } else if (typeof user.email !== 'string' || user.email.trim() === '') {",
              "            userFailures.push(\"email is empty or not a string\");",
              "        } else if (!emailRegex.test(user.email)) {",
              "            userFailures.push(`email '${user.email}' does not match regex pattern`);",
              "        }",
              "        ",
              "        if (userFailures.length > 0) {",
              "            failures.push({ index: index, id: user.id, issues: userFailures });",
              "        }",
              "    });",
              "    ",
              "    if (failures.length > 0) {",
              "        console.log(\"Email validation failures:\", JSON.stringify(failures, null, 2));",
              "    }",
              "    pm.expect(failures.length, \"Some users have invalid email fields\").to.equal(0);",
              "});",
              "",
              "// ============================================",
              "// Phone Field Validation",
              "// ============================================",
              "pm.test(\"Phone field validation for all users\", function () {",
              "    const loosePhonePattern = /^[\\d\\s\\-\\(\\)x\\.+]+$/;",
              "    let failures = [];",
              "    let warnings = [];",
              "    ",
              "    responseJson.forEach((user, index) => {",
              "        // Check phone exists and is non-empty",
              "        if (!user.hasOwnProperty('phone')) {",
              "            failures.push({ index: index, id: user.id, issue: \"phone field missing\" });",
              "        } else if (typeof user.phone !== 'string' || user.phone.trim() === '') {",
              "            failures.push({ index: index, id: user.id, issue: \"phone is empty or not a string\" });",
              "        } else if (!loosePhonePattern.test(user.phone)) {",
              "            // Optional: log if doesn't match loose phone pattern",
              "            warnings.push({ index: index, id: user.id, phone: user.phone, issue: \"phone does not match loose pattern\" });",
              "        }",
              "    });",
              "    ",
              "    if (warnings.length > 0) {",
              "        console.log(\"Phone pattern warnings (optional):\", JSON.stringify(warnings, null, 2));",
              "    }",
              "    if (failures.length > 0) {",
              "        console.log(\"Phone validation failures:\", JSON.stringify(failures, null, 2));",
              "    }",
              "    pm.expect(failures.length, \"Some users have missing or empty phone fields\").to.equal(0);",
              "});",
              "",
              "// ============================================",
              "// Company Object Validation",
              "// ============================================",
              "pm.test(\"Company object validation for all users\", function () {",
              "    let failures = [];",
              "    const requiredCompanyFields = ['name', 'catchPhrase', 'bs'];",
              "    ",
              "    responseJson.forEach((user, index) => {",
              "        let userFailures = [];",
              "        ",
              "        if (!user.hasOwnProperty('company') || typeof user.company !== 'object' || user.company === null) {",
              "            userFailures.push(\"company is missing or not an object\");",
              "        } else {",
              "            requiredCompanyFields.forEach(field => {",
              "                if (!user.company.hasOwnProperty(field)) {",
              "                    userFailures.push(`company.${field} is missing`);",
              "                }",
              "            });",
              "        }",
              "        ",
              "        if (userFailures.length > 0) {",
              "            failures.push({ index: index, id: user.id, issues: userFailures });",
              "        }",
              "    });",
              "    ",
              "    if (failures.length > 0) {",
              "        console.log(\"Company validation failures:\", JSON.stringify(failures, null, 2));",
              "    }",
              "    pm.expect(failures.length, \"Some users have invalid company objects\").to.equal(0);",
              "});",
              "",
              "// ============================================",
              "// First User Email Exact Match",
              "// ============================================",
              "pm.test(\"First user (index 0) has email exactly 'Sincere@april.biz'\", function () {",
              "    const firstUser = responseJson[0];",
              "    if (!firstUser) {",
              "        console.log(\"First user validation failure: No user at index 0\");",
              "        pm.expect.fail(\"No user found at index 0\");",
              "    }",
              "    if (firstUser.email !== \"Sincere@april.biz\") {",
              "        console.log(`First user email mismatch: expected 'Sincere@april.biz', got '${firstUser.email}'`);",
              "    }",
              "    pm.expect(firstUser.email).to.equal(\"Sincere@april.biz\");",
              "});",
              "",
              "// ============================================",
              "// Advanced: All Emails Are Unique",
              "// ============================================",
              "pm.test(\"All emails are unique across users\", function () {",
              "    const emails = responseJson.map((user, index) => ({ email: user.email, index: index, id: user.id }));",
              "    const emailSet = new Set();",
              "    let duplicates = [];",
              "    ",
              "    emails.forEach(item => {",
              "        if (emailSet.has(item.email)) {",
              "            duplicates.push(item);",
              "        } else {",
              "            emailSet.add(item.email);",
              "        }",
              "    });",
              "    ",
              "    if (duplicates.length > 0) {",
              "        console.log(\"Duplicate emails found:\", JSON.stringify(duplicates, null, 2));",
              "    }",
              "    pm.expect(duplicates.length, \"Duplicate emails found\").to.equal(0);",
              "});",
              "",
              "// ============================================",
              "// Advanced: All IDs Are Unique",
              "// ============================================",
              "pm.test(\"All ids are unique across users\", function () {",
              "    const ids = responseJson.map((user, index) => ({ id: user.id, index: index }));",
              "    const idSet = new Set();",
              "    let duplicates = [];",
              "    ",
              "    ids.forEach(item => {",
              "        if (idSet.has(item.id)) {",
              "            duplicates.push(item);",
              "        } else {",
              "            idSet.add(item.id);",
              "        }",
              "    });",
              "    ",
              "    if (duplicates.length > 0) {",
              "        console.log(\"Duplicate ids found:\", JSON.stringify(duplicates, null, 2));",
              "    }",
              "    pm.expect(duplicates.length, \"Duplicate ids found\").to.equal(0);",
              "});",
              "",
              "// ============================================",
              "// Advanced: Geo Coordinates Validation (lat/lng numeric)",
              "// ============================================",
              "pm.test(\"All users have valid geo coordinates (lat and lng are numeric)\", function () {",
              "    let failures = [];",
              "    ",
              "    responseJson.forEach((user, index) => {",
              "        let userFailures = [];",
              "        ",
              "        if (!user.address || !user.address.geo) {",
              "            userFailures.push(\"address.geo is missing\");",
              "        } else {",
              "            const geo = user.address.geo;",
              "            ",
              "            // Check lat exists and is numeric",
              "            if (!geo.hasOwnProperty('lat')) {",
              "                userFailures.push(\"lat is missing\");",
              "            } else {",
              "                const latNum = parseFloat(geo.lat);",
              "                if (!isFinite(latNum)) {",
              "                    userFailures.push(`lat '${geo.lat}' is not a finite number`);",
              "                }",
              "            }",
              "            ",
              "            // Check lng exists and is numeric",
              "            if (!geo.hasOwnProperty('lng')) {",
              "                userFailures.push(\"lng is missing\");",
              "            } else {",
              "                const lngNum = parseFloat(geo.lng);",
              "                if (!isFinite(lngNum)) {",
              "                    userFailures.push(`lng '${geo.lng}' is not a finite number`);",
              "                }",
              "            }",
              "        }",
              "        ",
              "        if (userFailures.length > 0) {",
              "            failures.push({ index: index, id: user.id, issues: userFailures });",
              "        }",
              "    });",
              "    ",
              "    if (failures.length > 0) {",
              "        console.log(\"Geo coordinates validation failures:\", JSON.stringify(failures, null, 2));",
              "    }",
              "    pm.expect(failures.length, \"Some users have invalid geo coordinates\").to.equal(0);",
              "});"
            ]
          }
        },
        {
          "listen": "prerequest",
          "script": {
            "exec": [
              ""
            ],
            "type": "text/javascript",
            "packages": {},
            "requests": {}
          }
        }
      ],
      "request": {
        "method": "GET",
        "header": [],
        "url": {
          "raw": "https://jsonplaceholder.typicode.com/users",
          "protocol": "https",
          "host": [
            "jsonplaceholder",
            "typicode",
            "com"
          ],
          "path": [
            "users"
          ]
        }
      },
      "response": []
    },
    {
      "name": "New Request",
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// Assuming previous tests / schema validations are above this line\r",
              "\r",
              "// 1. Validate that all users have a valid email\r",
              "pm.test(\"All users have valid email\", function () {\r",
              "    const users = pm.response.json();\r",
              "    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\r",
              "    let invalidUsers = [];\r",
              "\r",
              "    users.forEach((user, index) => {\r",
              "        const email = user.email;\r",
              "\r",
              "        if (\r",
              "            email === undefined ||\r",
              "            email === null ||\r",
              "            (typeof email === \"string\" && email.trim() === \"\") ||\r",
              "            !emailRegex.test(email)\r",
              "        ) {\r",
              "            invalidUsers.push({\r",
              "                index,\r",
              "                id: user.id,\r",
              "                email\r",
              "            });\r",
              "        }\r",
              "    });\r",
              "\r",
              "    if (invalidUsers.length > 0) {\r",
              "        console.log(\"Invalid emails found:\", invalidUsers);\r",
              "    }\r",
              "\r",
              "    pm.expect(\r",
              "        invalidUsers.length,\r",
              "        `Users with invalid email: ${JSON.stringify(invalidUsers)}`\r",
              "    ).to.equal(0);\r",
              "});\r",
              "\r",
              "// 2. Validate that all users have a phone number\r",
              "pm.test(\"All users have a phone number\", function () {\r",
              "    const users = pm.response.json();\r",
              "    // Very loose phone pattern (digits, spaces, +, -, ., x)\r",
              "    const phoneRegex = /^[0-9+\\-\\s().xX]+$/;\r",
              "    let missingPhones = [];\r",
              "    let nonStandardPhones = [];\r",
              "\r",
              "    users.forEach((user, index) => {\r",
              "        const phone = user.phone;\r",
              "\r",
              "        if (\r",
              "            phone === undefined ||\r",
              "            phone === null ||\r",
              "            (typeof phone === \"string\" && phone.trim() === \"\")\r",
              "        ) {\r",
              "            missingPhones.push({\r",
              "                index,\r",
              "                id: user.id,\r",
              "                phone\r",
              "            });\r",
              "        } else if (!phoneRegex.test(phone)) {\r",
              "            // Optional: log non-standard formats\r",
              "            nonStandardPhones.push({\r",
              "                index,\r",
              "                id: user.id,\r",
              "                phone\r",
              "            });\r",
              "        }\r",
              "    });\r",
              "\r",
              "    if (missingPhones.length > 0) {\r",
              "        console.log(\"Users with missing phone:\", missingPhones);\r",
              "    }\r",
              "    if (nonStandardPhones.length > 0) {\r",
              "        console.log(\"Users with non-standard phone format (warning only):\", nonStandardPhones);\r",
              "    }\r",
              "\r",
              "    pm.expect(\r",
              "        missingPhones.length,\r",
              "        `Users with missing phone: ${JSON.stringify(missingPhones)}`\r",
              "    ).to.equal(0);\r",
              "});\r",
              "\r",
              "// 3. Validate that each user has a company object with required sub-fields\r",
              "pm.test(\"All users have a valid company object\", function () {\r",
              "    const users = pm.response.json();\r",
              "    let invalidCompanies = [];\r",
              "\r",
              "    users.forEach((user, index) => {\r",
              "        const company = user.company;\r",
              "        const hasCompany =\r",
              "            company &&\r",
              "            typeof company === \"object\" &&\r",
              "            company.name !== undefined &&\r",
              "            company.catchPhrase !== undefined &&\r",
              "            company.bs !== undefined;\r",
              "\r",
              "        if (!hasCompany) {\r",
              "            invalidCompanies.push({\r",
              "                index,\r",
              "                id: user.id,\r",
              "                company\r",
              "            });\r",
              "        }\r",
              "    });\r",
              "\r",
              "    if (invalidCompanies.length > 0) {\r",
              "        console.log(\"Users with invalid/missing company:\", invalidCompanies);\r",
              "    }\r",
              "\r",
              "    pm.expect(\r",
              "        invalidCompanies.length,\r",
              "        `Users with invalid company: ${JSON.stringify(invalidCompanies)}`\r",
              "    ).to.equal(0);\r",
              "});\r",
              "\r",
              "// 4. Validate first userâ€™s email\r",
              "pm.test('First user email is \"Sincere@april.biz\"', function () {\r",
              "    const users = pm.response.json();\r",
              "    pm.expect(users).to.be.an(\"array\").that.is.not.empty;\r",
              "\r",
              "    const firstEmail = users[0].email;\r",
              "    if (firstEmail !== \"Sincere@april.biz\") {\r",
              "        console.log(\"First user email mismatch\", {\r",
              "            expected: \"Sincere@april.biz\",\r",
              "            actual: firstEmail,\r",
              "            user: users[0]\r",
              "        });\r",
              "    }\r",
              "\r",
              "    pm.expect(firstEmail, \"First user email mismatch\")\r",
              "      .to.equal(\"Sincere@april.biz\");\r",
              "});\r",
              "\r",
              "// 5a. Advanced: uniqueness of email\r",
              "pm.test(\"All user emails are unique\", function () {\r",
              "    const users = pm.response.json();\r",
              "    const seen = new Set();\r",
              "    let duplicates = [];\r",
              "\r",
              "    users.forEach((user, index) => {\r",
              "        const email = user.email;\r",
              "        if (seen.has(email)) {\r",
              "            duplicates.push({\r",
              "                index,\r",
              "                id: user.id,\r",
              "                email\r",
              "            });\r",
              "        }\r",
              "        seen.add(email);\r",
              "    });\r",
              "\r",
              "    if (duplicates.length > 0) {\r",
              "        console.log(\"Duplicate emails found:\", duplicates);\r",
              "    }\r",
              "\r",
              "    pm.expect(\r",
              "        duplicates.length,\r",
              "        `Duplicate emails: ${JSON.stringify(duplicates)}`\r",
              "    ).to.equal(0);\r",
              "});\r",
              "\r",
              "// 5b. Advanced: uniqueness of IDs\r",
              "pm.test(\"All user IDs are unique\", function () {\r",
              "    const users = pm.response.json();\r",
              "    const seen = new Set();\r",
              "    let duplicates = [];\r",
              "\r",
              "    users.forEach((user, index) => {\r",
              "        const id = user.id;\r",
              "        if (seen.has(id)) {\r",
              "            duplicates.push({\r",
              "                index,\r",
              "                id\r",
              "            });\r",
              "        }\r",
              "        seen.add(id);\r",
              "    });\r",
              "\r",
              "    if (duplicates.length > 0) {\r",
              "        console.log(\"Duplicate IDs found:\", duplicates);\r",
              "    }\r",
              "\r",
              "    pm.expect(\r",
              "        duplicates.length,\r",
              "        `Duplicate IDs: ${JSON.stringify(duplicates)}`\r",
              "    ).to.equal(0);\r",
              "});\r",
              "\r",
              "// 5c. Advanced: geo coordinates exist and are numeric\r",
              "pm.test(\"All users have numeric geo coordinates\", function () {\r",
              "    const users = pm.response.json();\r",
              "    let invalidGeos = [];\r",
              "\r",
              "    users.forEach((user, index) => {\r",
              "        const address = user.address;\r",
              "        const geo = address && address.geo;\r",
              "        const lat = geo && geo.lat;\r",
              "        const lng = geo && geo.lng;\r",
              "\r",
              "        const latNum = Number(lat);\r",
              "        const lngNum = Number(lng);\r",
              "\r",
              "        const valid =\r",
              "            geo &&\r",
              "            lat !== undefined &&\r",
              "            lng !== undefined &&\r",
              "            Number.isFinite(latNum) &&\r",
              "            Number.isFinite(lngNum);\r",
              "\r",
              "        if (!valid) {\r",
              "            invalidGeos.push({\r",
              "                index,\r",
              "                id: user.id,\r",
              "                geo\r",
              "            });\r",
              "        }\r",
              "    });\r",
              "\r",
              "    if (invalidGeos.length > 0) {\r",
              "        console.log(\"Users with invalid geo coordinates:\", invalidGeos);\r",
              "    }\r",
              "\r",
              "    pm.expect(\r",
              "        invalidGeos.length,\r",
              "        `Invalid geo coordinates: ${JSON.stringify(invalidGeos)}`\r",
              "    ).to.equal(0);\r",
              "});"
            ],
            "type": "text/javascript",
            "packages": {},
            "requests": {}
          }
        },
        {
          "listen": "prerequest",
          "script": {
            "exec": [],
            "type": "text/javascript"
          }
        }
      ],
      "request": {
        "method": "GET",
        "header": [],
        "url": {
          "raw": "https://jsonplaceholder.typicode.com/users",
          "protocol": "https",
          "host": [
            "jsonplaceholder",
            "typicode",
            "com"
          ],
          "path": [
            "users"
          ]
        }
      },
      "response": []
    },
    {
      "name": "New Request",
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// === RESPONSE TIME TESTS ===",
              "",
              "// Realistic response time test: less than 2000ms",
              "pm.test(\"Response time is less than 2000ms\", function () {",
              "    pm.expect(pm.response.responseTime).to.be.below(2000);",
              "});",
              "",
              "// Strict performance check: fail if response time is over 100ms",
              "pm.test(\"[STRICT] Response time should be under 100ms\", function () {",
              "    pm.expect(",
              "        pm.response.responseTime,",
              "        \"Response time was \" + pm.response.responseTime + \"ms, which exceeds the strict 100ms threshold\"",
              "    ).to.be.below(100);",
              "});",
              "",
              "// === JSON ARRAY AND FIRST POST VALIDATION ===",
              "",
              "pm.test(\"Response is a JSON array with first post having userId === 1\", function () {",
              "    const posts = pm.response.json();",
              "",
              "    // Basic structure checks",
              "    pm.expect(Array.isArray(posts), \"Response is not an array\").to.be.true;",
              "    pm.expect(posts.length, \"Posts array is empty\").to.be.above(0);",
              "",
              "    const firstPost = posts[0];",
              "",
              "    if (!firstPost || firstPost.userId !== 1) {",
              "        console.log(\"First post validation failed. Details:\", {",
              "            firstPost,",
              "            expectedUserId: 1",
              "        });",
              "    }",
              "",
              "    pm.expect(firstPost, \"First post is missing or null\").to.exist;",
              "    pm.expect(firstPost).to.have.property(\"userId\");",
              "    pm.expect(firstPost.userId, \"First post userId mismatch\").to.equal(1);",
              "});"
            ],
            "type": "text/javascript",
            "packages": {},
            "requests": {}
          }
        },
        {
          "listen": "prerequest",
          "script": {
            "exec": [],
            "type": "text/javascript"
          }
        }
      ],
      "request": {
        "method": "GET",
        "header": [],
        "url": {
          "raw": "https://jsonplaceholder.typicode.com/posts",
          "protocol": "https",
          "host": [
            "jsonplaceholder",
            "typicode",
            "com"
          ],
          "path": [
            "posts"
          ]
        }
      },
      "response": []
    },
    {
      "name": "New Request",
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "const response = pm.response.json();\r",
              "\r",
              "// 1. Basic Response Structure\r",
              "pm.test(\"1. Response is an array with 100 items\", () => {\r",
              "    pm.expect(response).to.be.an('array');\r",
              "    pm.expect(response.length).to.equal(100);\r",
              "});\r",
              "\r",
              "// 2. Data Type Validation (Schema-ish)\r",
              "pm.test(\"2. Every post has correct data types\", () => {\r",
              "    response.forEach((item) => {\r",
              "        pm.expect(item.userId).to.be.a('number');\r",
              "        pm.expect(item.id).to.be.a('number');\r",
              "        pm.expect(item.title).to.be.a('string');\r",
              "        pm.expect(item.body).to.be.a('string');\r",
              "    });\r",
              "});\r",
              "\r",
              "// 3. Unique ID Verification (Crucial for Databases)\r",
              "pm.test(\"3. All post IDs are unique (No Duplicates)\", () => {\r",
              "    const ids = response.map(post => post.id);\r",
              "    const uniqueIds = new Set(ids);\r",
              "    pm.expect(uniqueIds.size).to.equal(ids.length);\r",
              "});\r",
              "\r",
              "// 4. Value Range Check\r",
              "pm.test(\"4. UserIDs are within the expected range (1-10)\", () => {\r",
              "    response.forEach(post => {\r",
              "        pm.expect(post.userId).to.be.at.least(1);\r",
              "        pm.expect(post.userId).to.be.at.most(10);\r",
              "    });\r",
              "});\r",
              "\r",
              "// 5. Content Integrity: Title Length\r",
              "pm.test(\"5. All titles are meaningful (min 5 characters)\", () => {\r",
              "    response.forEach(post => {\r",
              "        pm.expect(post.title.length).to.be.above(5);\r",
              "    });\r",
              "});\r",
              "\r",
              "// 6. Content Integrity: Body Formatting\r",
              "pm.test(\"6. Bodies contain newline characters (verified format)\", () => {\r",
              "    // This checks if the data matches the specific format you pasted (\\n)\r",
              "    const postWithNewlines = response.filter(post => post.body.includes('\\n'));\r",
              "    pm.expect(postWithNewlines.length).to.be.above(0);\r",
              "});\r",
              "\r",
              "// 7. Specific Data Verification (Deep Link)\r",
              "pm.test(\"7. Post ID 10 has the correct title\", () => {\r",
              "    const post10 = response.find(post => post.id === 10);\r",
              "    pm.expect(post10.title).to.include(\"optio molestias id quia eum\");\r",
              "});\r",
              "\r",
              "// 8. Array Sorting Check\r",
              "pm.test(\"8. Posts are returned in ascending order by ID\", () => {\r",
              "    for (let i = 0; i < response.length - 1; i++) {\r",
              "        pm.expect(response[i].id).to.be.below(response[i+1].id);\r",
              "    }\r",
              "});\r",
              "\r",
              "// 9. Mandatory Field Presence (Negative Space Check)\r",
              "pm.test(\"9. No post has null or undefined fields\", () => {\r",
              "    response.forEach(post => {\r",
              "        pm.expect(post.userId).to.not.be.null;\r",
              "        pm.expect(post.id).to.not.be.null;\r",
              "        pm.expect(post.title).to.not.be.undefined;\r",
              "    });\r",
              "});\r",
              "\r",
              "// 10. Performance Check (SLA)\r",
              "pm.test(\"10. Response time is within SLA (under 500ms)\", () => {\r",
              "    pm.expect(pm.response.responseTime).to.be.below(500);\r",
              "});"
            ],
            "type": "text/javascript",
            "packages": {},
            "requests": {}
          }
        },
        {
          "listen": "prerequest",
          "script": {
            "exec": [
              ""
            ],
            "type": "text/javascript",
            "packages": {},
            "requests": {}
          }
        }
      ],
      "request": {
        "method": "GET",
        "header": [],
        "url": {
          "raw": "https://jsonplaceholder.typicode.com/posts",
          "protocol": "https",
          "host": [
            "jsonplaceholder",
            "typicode",
            "com"
          ],
          "path": [
            "posts"
          ]
        }
      },
      "response": []
    },
    {
      "name": "New Request",
      "request": {
        "method": "GET",
        "header": [],
        "url": {
          "raw": "{{base_url}}/users",
          "host": [
            "{{base_url}}"
          ],
          "path": [
            "users"
          ]
        }
      },
      "response": []
    }
  ]
}